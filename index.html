<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>OS Concepts - Operating Systems and Scheduling</title>
  <style>
    /* Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    /* CSS for just the feedback form in the footer */
.footer {
  background-color: #f1f5f9;
  padding: 3rem 2rem 1.5rem;
  margin-top: 3rem;
}
/* CSS for Team Information Section */
.team-info {
  background-color: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  margin-bottom: 2rem;
}

.team-info h3 {
  font-size: 1.3rem;
  margin-bottom: 1rem;
  color: #334155;
  text-align: center;
}

.team-members {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 1.5rem;
}

.team-member {
  text-align: center;
  transition: transform 0.2s;
}

.team-member:hover {
  transform: translateY(-5px);
}

.member-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  overflow: hidden;
  margin: 0 auto 0.8rem;
  border: 3px solid #e5deff;
}

.member-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.team-member h4 {
  margin: 0;
  font-size: 1.1rem;
  color: #1e293b;
}

.member-role {
  color: #7E69AB;
  font-weight: 600;
  font-size: 0.9rem;
  margin: 0.3rem 0;
}

.member-bio {
  font-size: 0.85rem;
  color: #64748b;
  line-height: 1.4;
  margin-top: 0.5rem;
}

.team-stats {
  display: flex;
  justify-content: space-around;
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid #f1f5f9;
}

.stat {
  text-align: center;
  padding: 0 1rem;
}

.stat-number {
  display: block;
  font-size: 1.8rem;
  font-weight: 700;
  color: #9b87f5;
}

.stat-label {
  display: block;
  font-size: 0.85rem;
  color: #64748b;
}

/* Media query for smaller screens */
@media (max-width: 640px) {
  .team-members {
    grid-template-columns: 1fr;
  }
  
  .team-stats {
    flex-direction: column;
    gap: 1rem;
  }
}

.footer-container {
  max-width: 1200px;
  margin: 0 auto;
}

.feedback-form {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.form-row {
  margin-bottom: 1rem;
}

.form-row.double {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}

@media (max-width: 480px) {
  .form-row.double {
    grid-template-columns: 1fr;
  }
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  font-size: 0.95rem;
  color: #334155;
}

.form-input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 1rem;
}

.form-input:focus {
  outline: none;
  border-color: #6366f1;
  box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
}

.form-textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 1rem;
  min-height: 120px;
  resize: vertical;
}

.form-textarea:focus {
  outline: none;
  border-color: #6366f1;
  box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
}

.submit-btn {
  background: #4f46e5;
  color: white;
  border: none;
  border-radius: 6px;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
  width: 100%;
}

.submit-btn:hover {
  background-color: #4338ca;
}

.submit-btn:disabled {
  background-color: #a5b4fc;
  cursor: not-allowed;
}

    body {
      background-color: #f7f7f9;
      color: #1A1F2C;
      line-height: 1.6;
    }
    
    /* Header */
    header {
      background-color: #1e40af;
      color: white;
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-weight: 600;
      font-size: 1.2rem;
    }
    
    nav ul {
      list-style: none;
      display: flex;
      gap: 1.5rem;
    }
    
    nav ul li a {
      color: white;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s;
    }
    
    nav ul li a:hover {
      color: #93c5fd;
    }
    
    /* Main Content */
    section {
      padding: 2rem;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2.5rem;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .gradient-text {
      background: linear-gradient(90deg, #4f46e5, #3b82f6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      display: inline-block;
    }
    
    h2 {
      color: #1e40af;
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    
    p {
      margin-bottom: 1rem;
    }
    
    /* Accordion Styles */
    .accordion {
      margin: 2rem 0;
    }
    
    .accordion-item {
      background: #ffffff;
      margin-bottom: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    
    .accordion-header {
      padding: 1rem;
      font-weight: 600;
      cursor: pointer;
      color: #4f46e5;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.6s ease;
      padding: 0 1rem;
    }
    
    .accordion-item.active .accordion-content {
      max-height: 1500px;
      padding: 0 1rem 1rem;
    }
    
    .accordion-header::after {
      content: "⌄";
      font-size: 1.5rem;
      transition: transform 0.3s;
    }
    
    .accordion-item.active .accordion-header::after {
      transform: rotate(180deg);
    }
    
    /* Feature Grid */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .feature-card {
      background-color: rgba(79, 70, 229, 0.05);
      padding: 1.25rem;
      border-radius: 8px;
      transition: background-color 0.3s;
    }
    
    .feature-card:hover {
      background-color: rgba(79, 70, 229, 0.1);
    }
    
    .feature-card h3 {
      color: #4f46e5;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    
    /* Highlight Box */
    .highlight {
      background-color: rgba(79, 70, 229, 0.1);
      border-left: 4px solid #4f46e5;
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 8px 8px 0;
    }
    
    /* Advantages/Disadvantages Grid */
    .advantages-disadvantages {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.25rem;
      margin: 1.5rem 0;
    }
    
    @media (max-width: 768px) {
      .advantages-disadvantages {
        grid-template-columns: 1fr;
      }
    }
    
    .advantages {
      background-color: rgba(34, 197, 94, 0.1);
      border-left: 4px solid #22c55e;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }
    
    .disadvantages {
      background-color: rgba(239, 68, 68, 0.1);
      border-left: 4px solid #ef4444;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }
    
    /* Examples Box */
    .examples {
      background-color: rgba(59, 130, 246, 0.1);
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    
    /* Tags */
    .tag {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background: #3b82f6;
      color: white;
      border-radius: 9999px;
      font-size: 0.75rem;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    
    /* Cards */
    .card {
      background: #ffffff;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin: 1rem 0;
      border: 1px solid #e2e8f0;
    }
    
    /* Back to Top Button */
    .back-to-top {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: #4f46e5;
      color: white;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s, background-color 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      font-size: 1.25rem;
      z-index: 40;
    }
    
    .back-to-top:hover {
      background-color: #4338ca;
    }
    
    .back-to-top.visible {
      opacity: 1;
    }
    
    /* CPU Scheduling Simulator */
    #simulator {
      padding: 2rem;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin: 2rem 0;
    }
    
    .steps {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .step {
      padding: 0.5rem 1rem;
      margin: 0 0.5rem;
      border-radius: 9999px;
      font-weight: 500;
    }
    
    .step.active {
      background-color: #9b87f5;
      color: white;
    }
    
    .step:not(.active) {
      background-color: #f1f0fb;
      color: #6E59A5;
    }
    
    .step-content {
      display: none;
    }
    
    .step-content.active {
      display: block;
    }
    
    /* Form controls */
    .form-group {
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    input, select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
    }
    
    input:focus, select:focus {
      outline: 2px solid #9b87f5;
      border-color: #9b87f5;
    }
    
    button {
      background-color: #9b87f5;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #7E69AB;
    }
    
    button.secondary {
      background-color: #6c757d;
    }
    
    button.secondary:hover {
      background-color: #5a6268;
    }
    
    /* Process table */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    
    th, td {
      padding: 0.75rem;
      text-align: center;
      border-bottom: 1px solid #eee;
    }
    
    th {
      background-color: #f1f0fb;
      font-weight: 600;
      color: #6E59A5;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid #eee;
      margin-bottom: 1rem;
    }
    
    .tab {
      padding: 0.75rem 1rem;
      cursor: pointer;
      font-weight: 500;
    }
    
    .tab.active {
      border-bottom: 2px solid #9b87f5;
      color: #6E59A5;
    }
    
    /* Gantt chart */
    .gantt-container {
      overflow-x: auto;
      margin: 1.5rem 0;
      padding: 0.5rem 0;
    }
    
    .gantt {
      display: flex;
      min-width: max-content;
    }
    
    .gantt-box {
      padding: 1rem 0.5rem;
      min-width: 60px;
      text-align: center;
      color: white;
      font-weight: 500;
      position: relative;
      border-right: 1px dashed rgba(255,255,255,0.3);
    }
    
    .time-marker {
      position: absolute;
      bottom: -20px;
      left: 0;
      font-size: 0.75rem;
      color: #666;
    }
    
    .time-marker.end {
      left: auto;
      right: 0;
    }
    
    /* Metrics */
    .metrics {
      background-color: #f1f0fb;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
      text-align: center;
    }
    
    .metric-group {
      display: inline-block;
      margin: 0 1rem;
    }
    
    .metric-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #6E59A5;
    }
    
    /* Footer */
    footer {
      text-align: center;
      padding: 2rem;
      background: #e5e7eb;
      color: #374151;
      margin-top: 3rem;
    }
    
    /* Form grid for two columns */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    
    @media (max-width: 640px) {
      .form-grid {
        grid-template-columns: 1fr;
      }
    }
    
    /* List styles */
    ul, ol {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }
    
    li {
      margin-bottom: 0.5rem;
    }
    
    /* Additional utility classes */
    .text-center {
      text-align: center;
    }
    
    .mb-2 {
      margin-bottom: 0.5rem;
    }
    
    .mb-4 {
      margin-bottom: 1rem;
    }
    
    .mt-4 {
      margin-top: 1rem;
    }
    
    .py-4 {
      padding-top: 1rem;
      padding-bottom: 1rem;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">OS Concepts</div>
    <nav>
      <ul>
        <li><a href="#home">Home</a></li>
        <li><a href="#scheduling">Scheduling</a></li>
        <li><a href="disk.html">File & I/O</a></li>
        <li><a href="osdetail.html">OS about</a></li>
      </ul>
    </nav>
  </header>

  <section id="home">
    <h1><span class="gradient-text">Operating Systems</span> and Their Types</h1>
    <p class="text-center text-lg mb-4">An in-depth exploration of various operating systems that power our digital world</p>
    
    <div class="accordion">
      <!-- What is an Operating System Section -->
      <div class="accordion-item active">
        <div class="accordion-header">What is an Operating System?</div>
        <div class="accordion-content">
          <p>
            An operating system (OS) is system software that acts as an intermediary between computer hardware and users. 
            It provides a platform for users and application programs to interact with the hardware. The operating system 
            is responsible for managing hardware resources like CPU, memory, input/output devices, and storage.
          </p>
          
          <p>
            The OS handles essential functions such as process management, memory management, file systems, device control, 
            and security. It ensures that tasks are executed efficiently, and system resources are allocated properly. 
            Without an operating system, users would need to interact with hardware directly, which would be complex and inefficient.
          </p>
          
          <div class="highlight">
            <p>An operating system serves as a resource manager, interface provider, and service center for computer hardware and software.</p>
          </div>

          <h2>Core Functions of Operating Systems</h2>
          <div class="feature-grid">
            <div class="feature-card">
              <h3>Process Management</h3>
              <p>Creating, scheduling, and terminating processes and threads</p>
            </div>
            <div class="feature-card">
              <h3>Memory Management</h3>
              <p>Allocating and deallocating memory space as needed</p>
            </div>
            <div class="feature-card">
              <h3>File System Management</h3>
              <p>Creating, accessing, and maintaining file structures</p>
            </div>
            <div class="feature-card">
              <h3>I/O Management</h3>
              <p>Controlling input/output devices and communications</p>
            </div>
            <div class="feature-card">
              <h3>Security Management</h3>
              <p>Protecting system resources and user data</p>
            </div>
            <div class="feature-card">
              <h3>User Interface</h3>
              <p>Providing GUI or CLI for user interaction</p>
            </div>
          </div>

          <p>
            Operating systems can be found in desktops, laptops, smartphones, embedded devices, and servers. 
            Common examples include Windows, Linux, macOS, Android, and iOS. Each is tailored for specific 
            hardware and user requirements. OS design can vary depending on whether it needs to prioritize 
            speed, security, multitasking, or real-time processing.
          </p>
        </div>
      </div>

      <!-- Batch Operating System -->
      <div class="accordion-item">
        <div class="accordion-header">1. Batch Operating System</div>
        <div class="accordion-content">
          <p>
            Batch operating systems were the earliest form of OS. Users did not interact directly with the system. 
            Instead, tasks were collected, grouped based on requirements, and processed in batches. 
            These jobs were executed one after the other with minimal idle CPU time.
          </p>
          
          <p>
            Batch OS uses job control languages (JCL) and is efficient for similar jobs. 
            For example, payroll systems and large-scale data processing benefit from batch processing.
          </p>
          
          <div class="advantages-disadvantages">
            <div class="advantages">
              <h3>Advantages:</h3>
              <ul>
                <li><strong>Resource Utilization:</strong> High efficiency in CPU usage</li>
                <li><strong>Low Idle Time:</strong> Continuous processing of jobs</li>
                <li><strong>Automation:</strong> No user intervention needed during execution</li>
                <li><strong>Cost-Effective:</strong> Useful for repetitive tasks</li>
              </ul>
            </div>
            
            <div class="disadvantages">
              <h3>Disadvantages:</h3>
              <ul>
                <li><strong>No Interaction:</strong> Users cannot interact during execution</li>
                <li><strong>Turnaround Time:</strong> Long wait times for job completion</li>
                <li><strong>Debugging:</strong> Difficult to debug batch processes</li>
                <li><strong>CPU Utilization:</strong> I/O-bound jobs may cause CPU underutilization</li>
              </ul>
            </div>
          </div>
          
          <div class="examples">
            <h3>Examples:</h3>
            <p>IBM OS/360, UNIVAC systems, IBM z/OS (modern implementation for mainframes)</p>
            <div>
              <span class="tag">Historical</span>
              <span class="tag">Mainframes</span>
              <span class="tag">Data Processing</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Time-Sharing Operating System -->
      <div class="accordion-item">
        <div class="accordion-header">2. Time-Sharing Operating System</div>
        <div class="accordion-content">
          <p>
            Time-sharing OS allows multiple users to use the system simultaneously. Each user gets a time slice of the CPU, 
            managed by the scheduler. The system switches rapidly between users to give the illusion of direct interaction.
          </p>
          
          <p>
            It introduced multitasking and allowed better utilization of CPU time. Key characteristics include 
            responsiveness, scheduling algorithms, and terminal access.
          </p>
          
          <div class="highlight">
            <p>Time-sharing systems brought about the concept of <strong>interactive computing</strong>, 
            where users could directly interact with the computer while it was processing.</p>
          </div>
          
          <div class="advantages-disadvantages">
            <div class="advantages">
              <h3>Advantages:</h3>
              <ul>
                <li><strong>Interactive Computing:</strong> Real-time user interaction</li>
                <li><strong>Fair Resource Allocation:</strong> CPU time is distributed equitably</li>
                <li><strong>Multiprogramming:</strong> Multiple programs can run concurrently</li>
                <li><strong>User Experience:</strong> Each user feels they have dedicated access</li>
              </ul>
            </div>
            
            <div class="disadvantages">
              <h3>Disadvantages:</h3>
              <ul>
                <li><strong>Security Challenges:</strong> Multiple users increase security risks</li>
                <li><strong>Complex Scheduling:</strong> Needs sophisticated scheduling algorithms</li>
                <li><strong>Resource Intensive:</strong> Requires more memory and system resources</li>
                <li><strong>Performance Issues:</strong> Can slow down with too many users</li>
              </ul>
            </div>
          </div>
          
          <div class="examples">
            <h3>Examples:</h3>
            <p>MULTICS, UNIX, Linux, macOS, Windows (modern operating systems incorporate time-sharing principles)</p>
            <div>
              <span class="tag">Multitasking</span>
              <span class="tag">Interactive</span>
              <span class="tag">Multi-user</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section id="scheduling">
    <h2>CPU Scheduling</h2>
    <p>CPU Scheduling is a fundamental concept in operating systems that determines which process runs on the CPU when multiple processes are ready to run. Efficient scheduling maximizes CPU usage and ensures responsiveness for all processes.</p>

    <div class="card">
      <h3>Types of CPU Scheduling Algorithms</h3>
      <ul>
        <li>FCFS (First-Come, First-Served)</li>
        <li>SJF (Shortest Job First)</li>
        <li>Priority Scheduling</li>
        <li>Round Robin (RR)</li>
        <li>Multilevel Queue Scheduling</li>
        <li>Multilevel Feedback Queue</li>
      </ul>
    </div>

    <!-- CPU Scheduling Simulator -->
    <div id="simulator">
      <h2 class="text-center">CPU Scheduling Simulator</h2>
      
      <div class="steps">
        <div class="step active" data-step="1">1. Select Algorithm</div>
        <div class="step" data-step="2">2. Add Processes</div>
        <div class="step" data-step="3">3. View Results</div>
      </div>
      
      <div class="step-content active" id="step1">
        <div class="card">
          <h3 class="text-center">Select Scheduling Algorithm</h3>
          <div class="form-group">
            <label for="algorithm">Choose Algorithm:</label>
            <select id="algorithm">
              <option value="">-- Select Algorithm --</option>
              <option value="FCFS">First Come First Served (FCFS)</option>
              <option value="SJF">Shortest Job First (Non-Preemptive)</option>
              <option value="SRTF">Shortest Remaining Time First (Preemptive)</option>
              <option value="PRIORITY">Priority Scheduling (Non-Preemptive)</option>
              <option value="RR">Round Robin</option>
            </select>
          </div>
          
          <div class="form-group" id="time-quantum-container" style="display:none;">
            <label for="time-quantum">Time Quantum:</label>
            <input type="number" id="time-quantum" min="1" value="2" />
          </div>
          
          <button id="select-algorithm-btn">Continue to Add Processes</button>
        </div>
      </div>
      
      <div class="step-content" id="step2">
        <div class="card">
          <h3 class="text-center">Add Processes for <span id="selected-algorithm">Algorithm</span></h3>
          <div class="form-grid">
            <div class="form-group">
              <label for="pid">Process ID:</label>
              <input type="text" id="pid" placeholder="e.g. P1" />
            </div>
            
            <div class="form-group">
              <label for="burst-time">Burst Time:</label>
              <input type="number" id="burst-time" min="1" placeholder="e.g. 5" />
            </div>
            
            <div class="form-group">
              <label for="arrival-time">Arrival Time:</label>
              <input type="number" id="arrival-time" min="0" placeholder="e.g. 0" />
            </div>
            
            <div class="form-group" id="priority-container" style="display:none;">
              <label for="priority">Priority (Lower is Higher):</label>
              <input type="number" id="priority" min="1" placeholder="e.g. 2" />
            </div>
          </div>
          
          <div>
            <button id="add-process-btn">Add Process</button>
            <button id="go-back-btn" class="secondary">Back to Algorithm Selection</button>
          </div>
        </div>
        
        <div class="card" id="process-list-container" style="display:none;">
          <h3 class="text-center">Process List</h3>
          <div style="overflow-x:auto;">
            <table id="process-table">
              <thead>
                <tr>
                  <th>Process ID</th>
                  <th>Arrival Time</th>
                  <th>Burst Time</th>
                  <th id="priority-header" style="display:none;">Priority</th>
                  <th>Action</th>
                </tr>
              </thead>
              <tbody id="process-table-body">
                <!-- Process entries will be populated here -->
              </tbody>
            </table>
          </div>
          
          <button id="run-algorithm-btn" class="mt-4">Run Algorithm</button>
        </div>
      </div>
      
      <div class="step-content" id="step3">
        <div class="card">
          <h3 class="text-center">Results for <span id="result-algorithm">Algorithm</span></h3>
          
          <div class="tabs">
            <div class="tab active" data-tab="gantt">Gantt Chart</div>
            <div class="tab" data-tab="table">Process Details</div>
          </div>
          
          <div id="gantt-tab" class="tab-content">
            <div class="gantt-container">
              <div class="gantt" id="gantt-chart">
                <!-- Gantt chart will be populated here -->
              </div>
            </div>
          </div>
          
          <div id="table-tab" class="tab-content" style="display:none;">
            <div style="overflow-x:auto;">
              <table id="results-table">
                <thead>
                  <tr>
                    <th>Process ID</th>
                    <th>Arrival Time</th>
                    <th>Burst Time</th>
                    <th id="result-priority-header" style="display:none;">Priority</th>
                    <th>Start Time</th>
                    <th>Completion Time</th>
                    <th>Turnaround Time</th>
                    <th>Waiting Time</th>
                  </tr>
                </thead>
                <tbody id="results-body">
                  <!-- Results will be populated here -->
                </tbody>
              </table>
            </div>
          </div>
          
          <div class="metrics">
            <div class="metric-group">
              <div>Average Turnaround Time</div>
              <div class="metric-value" id="avg-turnaround">0.00</div>
            </div>
            <div class="metric-group">
              <div>Average Waiting Time</div>
              <div class="metric-value" id="avg-waiting">0.00</div>
            </div>
          </div>
          
          <button id="start-over-btn" class="mt-4">Start Over</button>
        </div>
      </div>
    </div>
  </section>

  <section id="fileio">
    <h2>File and I/O Management</h2>
    <p>This section covers disk scheduling algorithms like FCFS, SSTF, SCAN, and C-SCAN with interactive visual tools.</p>

  </section>

 

  <div id="backToTop" class="back-to-top">↑</div>

  

  <script>
    // Global variables
    let currentStep = 1;
    let selectedAlgorithm = '';
    let processes = [];
    let showPriorityInputs = false;
    let showProcessList = false;
    
    const colors = [
      '#6E59A5', '#9b87f5', '#7E69AB', '#D946EF', '#8B5CF6', 
      '#F97316', '#0EA5E9', '#1EAEDB', '#33C3F0', '#0FA0CE'
    ];
    
    // DOM Elements
    const algorithmSelect = document.getElementById('algorithm');
    const timeQuantumContainer = document.getElementById('time-quantum-container');
    const timeQuantumInput = document.getElementById('time-quantum');
    const priorityContainer = document.getElementById('priority-container');
    const priorityHeader = document.getElementById('priority-header');
    const resultPriorityHeader = document.getElementById('result-priority-header');
    const selectedAlgorithmSpan = document.getElementById('selected-algorithm');
    const resultAlgorithmSpan = document.getElementById('result-algorithm');
    const processListContainer = document.getElementById('process-list-container');
    const processTableBody = document.getElementById('process-table-body');
    const ganttChart = document.getElementById('gantt-chart');
    const resultsBody = document.getElementById('results-body');
    const avgTurnaround = document.getElementById('avg-turnaround');
    const avgWaiting = document.getElementById('avg-waiting');
    
    // DOM Elements for Steps
    const stepElements = document.querySelectorAll('.step');
    const stepContents = document.querySelectorAll('.step-content');

    // DOM Elements for back to top button
    const backToTop = document.getElementById('backToTop');

    // Event Listeners
    document.getElementById('select-algorithm-btn').addEventListener('click', selectAlgorithm);
    document.getElementById('add-process-btn').addEventListener('click', addProcess);
    document.getElementById('go-back-btn').addEventListener('click', goBackToAlgorithm);
    document.getElementById('run-algorithm-btn').addEventListener('click', runScheduling);
    document.getElementById('start-over-btn').addEventListener('click', startOver);
    
    algorithmSelect.addEventListener('change', function() {
      const algorithm = this.value;
      timeQuantumContainer.style.display = algorithm === 'RR' ? 'block' : 'none';
      showPriorityInputs = algorithm === 'PRIORITY';
      priorityContainer.style.display = showPriorityInputs ? 'block' : 'none';
      priorityHeader.style.display = showPriorityInputs ? 'table-cell' : 'none';
      resultPriorityHeader.style.display = showPriorityInputs ? 'table-cell' : 'none';
    });

    // Back to top button
    window.addEventListener('scroll', function() {
      if (window.pageYOffset > 300) {
        backToTop.classList.add('visible');
      } else {
        backToTop.classList.remove('visible');
      }
    });
    
    backToTop.addEventListener('click', function() {
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    });

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const tabName = this.getAttribute('data-tab');
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Show correct content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        document.getElementById(`${tabName}-tab`).style.display = 'block';
      });
    });

    // Accordion functionality
    document.querySelectorAll('.accordion-header').forEach(header => {
      header.addEventListener('click', function() {
        const item = this.parentElement;
        const isActive = item.classList.contains('active');
        
        // Close all accordion items
        document.querySelectorAll('.accordion-item').forEach(accordionItem => {
          accordionItem.classList.remove('active');
          const content = accordionItem.querySelector('.accordion-content');
          content.style.maxHeight = '0';
        });
        
        // If the clicked item wasn't active, open it
        if (!isActive) {
          item.classList.add('active');
          const content = item.querySelector('.accordion-content');
          content.style.maxHeight = content.scrollHeight + 'px';
        }
      });
    });
    
    // Initialize first accordion item
    document.querySelector('.accordion-item').classList.add('active');
    const firstContent = document.querySelector('.accordion-item .accordion-content');
    firstContent.style.maxHeight = firstContent.scrollHeight + 'px';

    function selectAlgorithm() {
      selectedAlgorithm = algorithmSelect.value;
      
      if (!selectedAlgorithm) {
        alert('Please select an algorithm first.');
        return;
      }
      
      // Update UI for algorithm selection
      selectedAlgorithmSpan.textContent = algorithmSelect.options[algorithmSelect.selectedIndex].text;
      resultAlgorithmSpan.textContent = algorithmSelect.options[algorithmSelect.selectedIndex].text;
      
      // Reset processes for new algorithm
      processes = [];
      updateProcessTable();
      
      // Move to step 2
      goToStep(2);
    }

    function goToStep(step) {
      // Update step indicators
      stepElements.forEach(el => {
        el.classList.remove('active');
      });
      stepElements[step-1].classList.add('active');
      
      // Show selected step content
      stepContents.forEach(content => {
        content.classList.remove('active');
      });
      stepContents[step-1].classList.add('active');
      
      currentStep = step;
    }

    function goBackToAlgorithm() {
      goToStep(1);
    }

    function addProcess() {
      const pid = document.getElementById('pid').value.trim();
      const burstTime = parseInt(document.getElementById('burst-time').value);
      const arrivalTime = parseInt(document.getElementById('arrival-time').value);
      const priority = parseInt(document.getElementById('priority').value) || 1;

      // Validate inputs
      if (!pid || isNaN(burstTime) || burstTime <= 0 || isNaN(arrivalTime) || arrivalTime < 0) {
        alert('Please enter valid values for all fields.');
        return;
      }

      // Check for duplicate process ID
      if (processes.some(p => p.pid === pid)) {
        alert('A process with this ID already exists. Please use a unique ID.');
        return;
      }

      // Add new process
      processes.push({ pid, bt: burstTime, at: arrivalTime, prio: priority });
      
      // Reset input fields
      document.getElementById('pid').value = '';
      document.getElementById('burst-time').value = '';
      document.getElementById('arrival-time').value = '';
      document.getElementById('priority').value = '';
      
      // Update process table
      updateProcessTable();
      showProcessList = processes.length > 0;
      processListContainer.style.display = showProcessList ? 'block' : 'none';
    }

    function updateProcessTable() {
      // Clear table body
      processTableBody.innerHTML = '';
      
      // Add each process to the table
      processes.forEach((process, index) => {
        const row = document.createElement('tr');
        
        let cells = `
          <td>${process.pid}</td>
          <td>${process.at}</td>
          <td>${process.bt}</td>
        `;
        
        if (showPriorityInputs) {
          cells += `<td>${process.prio}</td>`;
        }
        
        cells += `<td><button onclick="deleteProcess(${index})" style="background-color:#ea384c; padding:4px 8px; font-size:0.875rem;">Delete</button></td>`;
        
        row.innerHTML = cells;
        processTableBody.appendChild(row);
      });
    }

    // This function needs to be global for the onclick handler
    function deleteProcess(index) {
      processes.splice(index, 1);
      updateProcessTable();
      showProcessList = processes.length > 0;
      processListContainer.style.display = showProcessList ? 'block' : 'none';
    }

    function startOver() {
      // Reset everything
      processes = [];
      selectedAlgorithm = '';
      algorithmSelect.value = '';
      timeQuantumInput.value = '2';
      timeQuantumContainer.style.display = 'none';
      updateProcessTable();
      showProcessList = false;
      processListContainer.style.display = 'none';
      
      // Go back to step 1
      goToStep(1);
    }

    function runScheduling() {
      if (processes.length === 0) {
        alert('Please add at least one process first.');
        return;
      }
      
      let results;
      
      switch (selectedAlgorithm) {
        case 'FCFS':
          results = calculateFCFS();
          break;
        case 'SJF':
          results = calculateSJF();
          break;
        case 'SRTF':
          results = calculateSRTF();
          break;
        case 'PRIORITY':
          results = calculatePriority();
          break;
        case 'RR':
          const timeQuantum = parseInt(timeQuantumInput.value);
          if (isNaN(timeQuantum) || timeQuantum <= 0) {
            alert('Please enter a valid time quantum.');
            return;
          }
          results = calculateRoundRobin(timeQuantum);
          break;
        default:
          alert('Please select an algorithm.');
          return;
      }
      
      displayResults(results);
      goToStep(3);
    }

    function calculateFCFS() {
      // Create deep copy of processes and sort by arrival time
      const sortedProcesses = JSON.parse(JSON.stringify(processes))
        .sort((a, b) => a.at - b.at);
      
      let currentTime = 0;
      const ganttData = [];
      
      // Calculate times for each process
      sortedProcesses.forEach(process => {
        // If process hasn't arrived yet, advance time
        if (currentTime < process.at) {
          currentTime = process.at;
        }
        
        // Set start time
        process.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: process.pid,
          start: currentTime,
          end: currentTime + process.bt,
          color: getProcessColor(process.pid)
        });
        
        // Update current time
        currentTime += process.bt;
        
        // Set completion time
        process.end = currentTime;
        
        // Calculate turnaround and waiting times
        process.tat = process.end - process.at;
        process.wt = process.tat - process.bt;
      });
      
      // Calculate averages
      const avgTAT = sortedProcesses.reduce((sum, p) => sum + p.tat, 0) / sortedProcesses.length;
      const avgWT = sortedProcesses.reduce((sum, p) => sum + p.wt, 0) / sortedProcesses.length;
      
      return {
        processes: sortedProcesses,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateSJF() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && !p.completed);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => !p.completed)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find shortest job among eligible processes
        let shortestJob = eligible.reduce(
          (min, p) => p.bt < min.bt ? p : min, 
          eligible[0]
        );
        
        // Mark start time
        shortestJob.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: shortestJob.pid,
          start: currentTime,
          end: currentTime + shortestJob.bt,
          color: getProcessColor(shortestJob.pid)
        });
        
        // Update current time
        currentTime += shortestJob.bt;
        
        // Mark completion
        shortestJob.completed = true;
        shortestJob.end = currentTime;
        shortestJob.tat = shortestJob.end - shortestJob.at;
        shortestJob.wt = shortestJob.tat - shortestJob.bt;
        completed++;
      }
      
      // Remove temporary 'completed' property
      processData.forEach(p => delete p.completed);
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateSRTF() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      // Initialize remaining time for each process
      processData.forEach(p => {
        p.remaining = p.bt;
        p.executed = false;
      });
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      let previousProcess = null;
      let startTime = 0;
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && p.remaining > 0);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => p.remaining > 0)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find process with shortest remaining time
        let shortestJob = eligible.reduce(
          (min, p) => p.remaining < min.remaining ? p : min, 
          eligible[0]
        );
        
        // If this is the first time this process executes, mark its start time
        if (!shortestJob.executed) {
          shortestJob.start = currentTime;
          shortestJob.executed = true;
        }
        
        // If process changes, add previous process execution to Gantt chart
        if (previousProcess !== null && previousProcess !== shortestJob.pid) {
          ganttData.push({
            pid: previousProcess,
            start: startTime,
            end: currentTime,
            color: getProcessColor(previousProcess)
          });
          
          startTime = currentTime;
        } else if (previousProcess === null) {
          startTime = currentTime;
        }
        
        // Update previous process
        previousProcess = shortestJob.pid;
        
        // Execute for 1 time unit
        shortestJob.remaining--;
        currentTime++;
        
        // Check if process completed
        if (shortestJob.remaining === 0) {
          // Mark completion
          shortestJob.end = currentTime;
          shortestJob.tat = shortestJob.end - shortestJob.at;
          shortestJob.wt = shortestJob.tat - shortestJob.bt;
          completed++;
          
          // Add to Gantt chart
          ganttData.push({
            pid: shortestJob.pid,
            start: startTime,
            end: currentTime,
            color: getProcessColor(shortestJob.pid)
          });
          
          previousProcess = null;
          startTime = currentTime;
        }
      }
      
      // Remove temporary properties
      processData.forEach(p => {
        delete p.remaining;
        delete p.executed;
      });
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculatePriority() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && !p.completed);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => !p.completed)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find process with highest priority (lower number = higher priority)
        let highestPriority = eligible.reduce(
          (min, p) => p.prio < min.prio ? p : min, 
          eligible[0]
        );
        
        // Mark start time
        highestPriority.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: highestPriority.pid,
          start: currentTime,
          end: currentTime + highestPriority.bt,
          color: getProcessColor(highestPriority.pid)
        });
        
        // Update current time
        currentTime += highestPriority.bt;
        
        // Mark completion
        highestPriority.completed = true;
        highestPriority.end = currentTime;
        highestPriority.tat = highestPriority.end - highestPriority.at;
        highestPriority.wt = highestPriority.tat - highestPriority.bt;
        completed++;
      }
      
      // Remove temporary 'completed' property
      processData.forEach(p => delete p.completed);
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateRoundRobin(timeQuantum) {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      // Initialize remaining time for each process
      processData.forEach(p => {
        p.remaining = p.bt;
        p.executed = false;
        p.inQueue = false;
      });
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      const readyQueue = [];
      
      // Continue until all processes are completed
      while (completed < processData.length || readyQueue.length > 0) {
        // Add newly arrived processes to ready queue
        processData.forEach(p => {
          if (p.at <= currentTime && !p.inQueue && p.remaining > 0) {
            readyQueue.push(p);
            p.inQueue = true;
          }
        });
        
        if (readyQueue.length === 0) {
          // If no processes in ready queue, advance time to next arrival
          const remainingProcesses = processData.filter(p => p.remaining > 0 && !p.inQueue);
          if (remainingProcesses.length > 0) {
            const nextArrival = Math.min(...remainingProcesses.map(p => p.at));
            currentTime = nextArrival;
            continue;
          } else {
            // All processes have completed
            break;
          }
        }
        
        // Get next process from ready queue
        const currentProcess = readyQueue.shift();
        
        // If this is the first time this process executes, mark its start time
        if (!currentProcess.executed) {
          currentProcess.start = currentTime;
          currentProcess.executed = true;
        }
        
        // Calculate execution time (either time quantum or remaining time, whichever is smaller)
        const executeTime = Math.min(timeQuantum, currentProcess.remaining);
        
        // Add to Gantt chart
        ganttData.push({
          pid: currentProcess.pid,
          start: currentTime,
          end: currentTime + executeTime,
          color: getProcessColor(currentProcess.pid)
        });
        
        // Update current time and remaining time
        currentTime += executeTime;
        currentProcess.remaining -= executeTime;
        
        // Add newly arrived processes to ready queue
        processData.forEach(p => {
          if (p.at <= currentTime && !p.inQueue && p.remaining > 0) {
            readyQueue.push(p);
            p.inQueue = true;
          }
        });
        
        // Check if process completed
        if (currentProcess.remaining === 0) {
          // Mark completion
          currentProcess.end = currentTime;
          currentProcess.tat = currentProcess.end - currentProcess.at;
          currentProcess.wt = currentProcess.tat - currentProcess.bt;
          completed++;
        } else {
          // Put back in ready queue
          readyQueue.push(currentProcess);
        }
      }
      
      // Remove temporary properties
      processData.forEach(p => {
        delete p.remaining;
        delete p.executed;
        delete p.inQueue;
      });
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function displayResults(results) {
      // Clear previous results
      ganttChart.innerHTML = '';
      resultsBody.innerHTML = '';
      
      // Display Gantt chart
      results.ganttData.forEach((item, index) => {
        const width = (item.end - item.start) * 40; // 40px per time unit
        
        const ganttBox = document.createElement('div');
        ganttBox.className = 'gantt-box';
        ganttBox.style.backgroundColor = item.color;
        ganttBox.style.width = `${width}px`;
        ganttBox.textContent = item.pid;
        
        // Add start time marker
        const startMarker = document.createElement('div');
        startMarker.className = 'time-marker';
        startMarker.textContent = item.start;
        ganttBox.appendChild(startMarker);
        
        // Add end time marker (only for the last item)
        if (index === results.ganttData.length - 1) {
          const endMarker = document.createElement('div');
          endMarker.className = 'time-marker end';
          endMarker.textContent = item.end;
          ganttBox.appendChild(endMarker);
        }
        
        ganttChart.appendChild(ganttBox);
      });
      
      // Display process details
      results.processes.forEach(process => {
        const row = document.createElement('tr');
        
        let cells = `
          <td>${process.pid}</td>
          <td>${process.at}</td>
          <td>${process.bt}</td>
        `;
        
        if (showPriorityInputs) {
          cells += `<td>${process.prio}</td>`;
        }
        
        cells += `
          <td>${process.start}</td>
          <td>${process.end}</td>
          <td>${process.tat}</td>
          <td>${process.wt}</td>
        `;
        
        row.innerHTML = cells;
        resultsBody.appendChild(row);
      });
      
      // Display average metrics
      avgTurnaround.textContent = results.avgTAT.toFixed(2);
      avgWaiting.textContent = results.avgWT.toFixed(2);
      
      // Set first tab as active
      document.querySelector('.tab').click();
    }

    function getProcessColor(pid) {
      // Generate a consistent color based on process ID
      const index = Array.from(pid).reduce((sum, char) => sum + char.charCodeAt(0), 0) % colors.length;
      return colors[index];
    }
    // JavaScript for the feedback form functionality
document.addEventListener('DOMContentLoaded', function() {
  const feedbackForm = document.getElementById('feedbackForm');
  const submitBtn = document.getElementById('submitBtn');
  
  if (feedbackForm) {
    feedbackForm.addEventListener('submit', function(e) {
      e.preventDefault();
      
      // Disable button to prevent multiple submissions
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';
      
      // Get form values
      const name = document.getElementById('name').value;
      const email = document.getElementById('email').value;
      const feedback = document.getElementById('feedback').value;
      
      // Simulate form submission with a timeout
      setTimeout(() => {
        // In a real application, you would send this data to a server
        console.log('Feedback submitted:', { name, email, feedback });
        
        // Show success message
        alert('Thank you for your feedback!');
        
        // Reset form
        feedbackForm.reset();
        
        // Re-enable button
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit Feedback';
      }, 1000);
    });
  }
});
// JavaScript for Team Information Section with animation
document.addEventListener('DOMContentLoaded', function() {
  // Fade in team members when they come into view
  const teamMembers = document.querySelectorAll('.team-member');
  
  if ('IntersectionObserver' in window) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.style.opacity = '1';
          observer.unobserve(entry.target);
        }
      });
    }, { threshold: 0.1 });
    
    teamMembers.forEach(member => {
      member.style.opacity = '0';
      member.style.transition = 'opacity 0.6s ease-in-out';
      observer.observe(member);
    });
  }
  
  // Animate stat numbers counting up
  const statNumbers = document.querySelectorAll('.stat-number');
  
  if ('IntersectionObserver' in window) {
    const statsObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const target = entry.target;
          const finalValue = parseInt(target.textContent);
          let startValue = 0;
          const duration = 1500;
          const step = Math.ceil(finalValue / (duration / 20));
          
          function updateValue() {
            startValue += step;
            if (startValue > finalValue) {
              target.textContent = finalValue + (target.textContent.includes('+') ? '+' : '');
            } else {
              target.textContent = startValue + (target.textContent.includes('+') ? '+' : '');
              setTimeout(updateValue, 20);
            }
          }
          
          updateValue();
          statsObserver.unobserve(target);
        }
      });
    }, { threshold: 0.5 });
    
    statNumbers.forEach(stat => {
      statsObserver.observe(stat);
    });
  }
});

  </script>
  <!-- Footer section with just the feedback form -->
<footer class="footer">
  <div class="footer-container">
    <!-- Feedback Form -->
    <div class="feedback-form">
      <h3>Share Your Feedback</h3>
      <form id="feedbackForm">
        <div class="form-row double">
          <div>
            <label for="name" class="form-label">Name</label>
            <input type="text" id="name" class="form-input" placeholder="Your name" required>
          </div>
          <div>
            <label for="email" class="form-label">Email</label>
            <input type="email" id="email" class="form-input" placeholder="Your email" required>
          </div>
        </div>
        <div class="form-row">
          <label for="feedback" class="form-label">Your Feedback</label>
          <textarea id="feedback" class="form-textarea" placeholder="Share your thoughts about this resource..." required></textarea>
        </div>
        <div class="form-row">
          <button type="submit" class="submit-btn" id="submitBtn">Submit Feedback</button>
        </div>
      </form>
    </div>
  </div>
  <!-- Team Information Section for Footer -->
<div class="team-info">
  <h3>Creator</h3>
  <div class="team-members">
    <div class="team-member">
      <div class="member-avatar">
        <img src="abc.jpg" alt="Team Member">
      </div>
      <h4>Vaibhav K. Gawande</h4>
      <p class="member-role">Project Idea</p>
      <p class="member-bio">CSE 2nd Year </p>
    </div>
    
  
    
  
  <div class="team-stats">
    <div class="stat">
      <span class="stat-number">5+</span>
      <span class="stat-label">learning Student</span>
    </div>
   
  </div>
</div>

</footer>

</body>
</html>
