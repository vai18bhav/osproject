<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   Operating Systems Concepts - CPU Scheduling Simulator
  </title>
  <style>
   /* General styling */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      padding: 20px;
      background: #f7f7f9;
      color: #1A1F2C;
      line-height: 1.5;
    }
    
    h1, h2, h3 {
      color: #6E59A5;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    
    .card {
      background: white;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
      margin-bottom: 20px;
    }
    
    /* Form controls */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }
    
    @media (max-width: 640px) {
      .form-grid {
        grid-template-columns: 1fr;
      }
    }
    
    .form-group {
      margin-bottom: 16px;
    }
    
    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 500;
    }
    
    input, select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
      background-color: white;
    }
    
    input:focus, select:focus {
      outline: 2px solid #9b87f5;
      border-color: #9b87f5;
    }
    
    button {
      background-color: #9b87f5;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 10px 16px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #7E69AB;
    }
    
    /* Process list */
    .process-list {
      margin: 20px 0;
    }
    
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 16px 0;
      background-color: white;
      border-radius: 8px;
      overflow: hidden;
    }
    
    th, td {
      padding: 12px;
      text-align: center;
      border-bottom: 1px solid #eee;
    }
    
    th {
      background-color: #f1f0fb;
      font-weight: 600;
      color: #6E59A5;
    }
    
    tr:last-child td {
      border-bottom: none;
    }
    
    .action-btn {
      background-color: #ea384c;
      padding: 6px 10px;
      font-size: 0.875rem;
    }
    
    /* Gantt chart */
    .gantt-container {
      overflow-x: auto;
      margin-top: 16px;
      padding: 8px 0;
    }
    
    .gantt {
      display: flex;
      padding: 10px 0;
      min-width: max-content;
    }
    
    .gantt-box {
      position: relative;
      padding: 16px 8px;
      min-width: 60px;
      text-align: center;
      color: white;
      font-weight: 500;
      border-right: 1px dashed rgba(255,255,255,0.3);
    }
    
    .time-marker {
      position: absolute;
      bottom: -25px;
      left: 0;
      font-size: 0.75rem;
      color: #666;
    }
    
    .time-marker.end {
      left: auto;
      right: 0;
    }
    
    /* Metrics */
    .metrics {
      background-color: #f1f0fb;
      padding: 16px;
      border-radius: 8px;
      margin-top: 16px;
      text-align: center;
    }
    
    .metric-group {
      display: inline-block;
      margin: 0 16px;
    }
    
    .metric-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #6E59A5;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      margin-bottom: 16px;
      border-bottom: 1px solid #eee;
    }
    
    .tab {
      padding: 10px 16px;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      font-weight: 500;
    }
    
    .tab.active {
      border-bottom-color: #9b87f5;
      color: #6E59A5;
    }
    
    /* New styles for algorithm-first approach */
    .steps-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .step {
      padding: 8px 16px;
      background: #f1f0fb;
      border-radius: 20px;
      margin: 0 8px;
      color: #6E59A5;
      font-weight: 500;
    }
    
    .step.active {
      background: #9b87f5;
      color: white;
    }
    
    .step-content {
      display: none;
    }
    
    .step-content.active {
      display: block;
    }
   .floating-logo {
  font-weight: 700;
  font-size: 1.5rem;
  background: linear-gradient(45deg, #facc15, #f472b6, #60a5fa, #8b5cf6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: float-shine 4s infinite ease-in-out;
}

@keyframes float-shine {
  0% { transform: translateY(0px); text-shadow: 0 0 5px rgba(255,255,255,0.5); }
  50% { transform: translateY(-3px); text-shadow: 0 0 20px rgba(255,255,255,0.9); }
  100% { transform: translateY(0px); text-shadow: 0 0 5px rgba(255,255,255,0.5); }
}
   /* Responsive Enhancements */
@media (max-width: 768px) {
  header, .container, nav, .form-grid, .grid, .steps-container, .advantages-disadvantages {
    flex-direction: column !important;
    grid-template-columns: 1fr !important;
    text-align: center;
    gap: 1rem;
  }

  .logo {
    font-size: 1.25rem !important;
    text-align: center;
    width: 100%;
  }

  nav a {
    display: block;
    margin: 0.5rem 0;
  }

  .form-group {
    width: 100%;
  }

  input, select, button {
    font-size: 1rem;
    padding: 0.75rem !important;
  }

  table, th, td {
    font-size: 0.9rem;
  }

  .gantt-box {
    min-width: 40px !important;
    font-size: 0.75rem;
  }

  .step {
    margin-bottom: 0.5rem;
  }

  h1, h2 {
    font-size: 1.5rem !important;
  }

  .tab-buttons {
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .tab-button {
    flex: 1 1 auto;
    min-width: 100px;
  }
}
   /* Synced navbar styles from index */

    /* Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    }
    /* CSS for just the feedback form in the footer */
.footer {
  background-color: #f1f5f9;
  padding: 3rem 2rem 1.5rem;
  margin-top: 3rem;
}
/* CSS for Team Information Section */
.team-info {
  background-color: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  margin-bottom: 2rem;
}

.team-info h3 {
  font-size: 1.3rem;
  margin-bottom: 1rem;
  color: #334155;
  text-align: center;
}

.team-members {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1.5rem;
  margin-bottom: 1.5rem;
}

.team-member {
  text-align: center;
  transition: transform 0.2s;
}

.team-member:hover {
  transform: translateY(-5px);
}

.member-avatar {
  width: 80px;
  height: 80px;
  border-radius: 50%;
  overflow: hidden;
  margin: 0 auto 0.8rem;
  border: 3px solid #e5deff;
}

.member-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.team-member h4 {
  margin: 0;
  font-size: 1.1rem;
  color: #1e293b;
}

.member-role {
  color: #7E69AB;
  font-weight: 600;
  font-size: 0.9rem;
  margin: 0.3rem 0;
}

.member-bio {
  font-size: 0.85rem;
  color: #64748b;
  line-height: 1.4;
  margin-top: 0.5rem;
}

.team-stats {
  display: flex;
  justify-content: space-around;
  margin-top: 1.5rem;
  padding-top: 1.5rem;
  border-top: 1px solid #f1f5f9;
}

.stat {
  text-align: center;
  padding: 0 1rem;
}

.stat-number {
  display: block;
  font-size: 1.8rem;
  font-weight: 700;
  color: #9b87f5;
}

.stat-label {
  display: block;
  font-size: 0.85rem;
  color: #64748b;
}

/* Media query for smaller screens */
@media (max-width: 640px) {
  .team-members {
    grid-template-columns: 1fr;
  }
  
  .team-stats {
    flex-direction: column;
    gap: 1rem;
  }
}

.footer-container {
  max-width: 1200px;
  margin: 0 auto;
}

.feedback-form {
  background: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.form-row {
  margin-bottom: 1rem;
}

.form-row.double {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
}

@media (max-width: 480px) {
  .form-row.double {
    grid-template-columns: 1fr;
  }
}

.form-label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 500;
  font-size: 0.95rem;
  color: #334155;
}

.form-input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 1rem;
}

.form-input:focus {
  outline: none;
  border-color: #6366f1;
  box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
}

.form-textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #cbd5e1;
  border-radius: 6px;
  font-size: 1rem;
  min-height: 120px;
  resize: vertical;
}

.form-textarea:focus {
  outline: none;
  border-color: #6366f1;
  box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.1);
}

.submit-btn {
  background: #4f46e5;
  color: white;
  border: none;
  border-radius: 6px;
  padding: 0.75rem 1.5rem;
  font-size: 1rem;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
  width: 100%;
}

.submit-btn:hover {
  background-color: #4338ca;
}

.submit-btn:disabled {
  background-color: #a5b4fc;
  cursor: not-allowed;
}

    body {
      background-color: #f7f7f9;
      color: #1A1F2C;
      line-height: 1.6;
    }
    
    /* Header */
    header {
      background-color: #1e40af;
      color: white;
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      font-weight: 600;
      font-size: 1.2rem;
    }
    
    nav ul {
      list-style: none;
      display: flex;
      gap: 1.5rem;
    }
    
    nav ul li a {
      color: white;
      text-decoration: none;
      font-weight: 500;
      transition: color 0.3s;
    }
    
    nav ul li a:hover {
      color: #93c5fd;
    }
    
    /* Main Content */
    section {
      padding: 2rem;
      max-width: 1000px;
      margin: 0 auto;
    }
    
    h1 {
      font-size: 2.5rem;
      text-align: center;
      margin-bottom: 1.5rem;
    }
    
    .gradient-text {
      background: linear-gradient(90deg, #4f46e5, #3b82f6);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      display: inline-block;
    }
    
    h2 {
      color: #1e40af;
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    
    p {
      margin-bottom: 1rem;
    }
    
    /* Accordion Styles */
    .accordion {
      margin: 2rem 0;
    }
    
    .accordion-item {
      background: #ffffff;
      margin-bottom: 1rem;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      overflow: hidden;
    }
    
    .accordion-header {
      padding: 1rem;
      font-weight: 600;
      cursor: pointer;
      color: #4f46e5;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .accordion-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.6s ease;
      padding: 0 1rem;
    }
    
    .accordion-item.active .accordion-content {
      max-height: 1500px;
      padding: 0 1rem 1rem;
    }
    
    .accordion-header::after {
      content: "⌄";
      font-size: 1.5rem;
      transition: transform 0.3s;
    }
    
    .accordion-item.active .accordion-header::after {
      transform: rotate(180deg);
    }
    
    /* Feature Grid */
    .feature-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 1rem;
      margin: 1.5rem 0;
    }
    
    .feature-card {
      background-color: rgba(79, 70, 229, 0.05);
      padding: 1.25rem;
      border-radius: 8px;
      transition: background-color 0.3s;
    }
    
    .feature-card:hover {
      background-color: rgba(79, 70, 229, 0.1);
    }
    
    .feature-card h3 {
      color: #4f46e5;
      margin-bottom: 0.5rem;
      font-weight: 600;
    }
    
    /* Highlight Box */
    .highlight {
      background-color: rgba(79, 70, 229, 0.1);
      border-left: 4px solid #4f46e5;
      padding: 1rem;
      margin: 1.5rem 0;
      border-radius: 0 8px 8px 0;
    }
    
    /* Advantages/Disadvantages Grid */
    .advantages-disadvantages {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.25rem;
      margin: 1.5rem 0;
    }
    
    @media (max-width: 768px) {
      .advantages-disadvantages {
        grid-template-columns: 1fr;
      }
    }
    
    .advantages {
      background-color: rgba(34, 197, 94, 0.1);
      border-left: 4px solid #22c55e;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }
    
    .disadvantages {
      background-color: rgba(239, 68, 68, 0.1);
      border-left: 4px solid #ef4444;
      padding: 1rem;
      border-radius: 0 8px 8px 0;
    }
    
    /* Examples Box */
    .examples {
      background-color: rgba(59, 130, 246, 0.1);
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    
    /* Tags */
    .tag {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background: #3b82f6;
      color: white;
      border-radius: 9999px;
      font-size: 0.75rem;
      margin-right: 0.5rem;
      margin-top: 0.5rem;
    }
    
    /* Cards */
    .card {
      background: #ffffff;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      margin: 1rem 0;
      border: 1px solid #e2e8f0;
    }
    
    /* Back to Top Button */
    .back-to-top {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: #4f46e5;
      color: white;
      width: 2.5rem;
      height: 2.5rem;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.3s, background-color 0.3s;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      font-size: 1.25rem;
      z-index: 40;
    }
    
    .back-to-top:hover {
      background-color: #4338ca;
    }
    
    .back-to-top.visible {
      opacity: 1;
    }
    
    /* CPU Scheduling Simulator */
    #simulator {
      padding: 2rem;
      background-color: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin: 2rem 0;
    }
    
    .steps {
      display: flex;
      justify-content: center;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .step {
      padding: 0.5rem 1rem;
      margin: 0 0.5rem;
      border-radius: 9999px;
      font-weight: 500;
    }
    
    .step.active {
      background-color: #9b87f5;
      color: white;
    }
    
    .step:not(.active) {
      background-color: #f1f0fb;
      color: #6E59A5;
    }
    
    .step-content {
      display: none;
    }
    
    .step-content.active {
      display: block;
    }
    
    /* Form controls */
    .form-group {
      margin-bottom: 1rem;
    }
    
    label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 500;
    }
    
    input, select {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 1rem;
    }
    
    input:focus, select:focus {
      outline: 2px solid #9b87f5;
      border-color: #9b87f5;
    }
    
    button {
      background-color: #9b87f5;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #7E69AB;
    }
    
    button.secondary {
      background-color: #6c757d;
    }
    
    button.secondary:hover {
      background-color: #5a6268;
    }
    
    /* Process table */
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }
    
    th, td {
      padding: 0.75rem;
      text-align: center;
      border-bottom: 1px solid #eee;
    }
    
    th {
      background-color: #f1f0fb;
      font-weight: 600;
      color: #6E59A5;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 1px solid #eee;
      margin-bottom: 1rem;
    }
    
    .tab {
      padding: 0.75rem 1rem;
      cursor: pointer;
      font-weight: 500;
    }
    
    .tab.active {
      border-bottom: 2px solid #9b87f5;
      color: #6E59A5;
    }
    
    /* Gantt chart */
    .gantt-container {
      overflow-x: auto;
      margin: 1.5rem 0;
      padding: 0.5rem 0;
    }
    
    .gantt {
      display: flex;
      min-width: max-content;
    }
    
    .gantt-box {
      padding: 1rem 0.5rem;
      min-width: 60px;
      text-align: center;
      color: white;
      font-weight: 500;
      position: relative;
      border-right: 1px dashed rgba(255,255,255,0.3);
    }
    
    .time-marker {
      position: absolute;
      bottom: -20px;
      left: 0;
      font-size: 0.75rem;
      color: #666;
    }
    
    .time-marker.end {
      left: auto;
      right: 0;
    }
    
    /* Metrics */
    .metrics {
      background-color: #f1f0fb;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
      text-align: center;
    }
    
    .metric-group {
      display: inline-block;
      margin: 0 1rem;
    }
    
    .metric-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #6E59A5;
    }
    
    /* Footer */
    footer {
      text-align: center;
      padding: 2rem;
      background: #e5e7eb;
      color: #374151;
      margin-top: 3rem;
    }
    
    /* Form grid for two columns */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    
    @media (max-width: 640px) {
      .form-grid {
        grid-template-columns: 1fr;
      }
    }
    
    /* List styles */
    ul, ol {
      margin-left: 1.5rem;
      margin-bottom: 1rem;
    }
    
    li {
      margin-bottom: 0.5rem;
    }
    
    /* Additional utility classes */
    .text-center {
      text-align: center;
    }
    
    .mb-2 {
      margin-bottom: 0.5rem;
    }
    
    .mb-4 {
      margin-bottom: 1rem;
    }
    
    .mt-4 {
      margin-top: 1rem;
    }
    
    .py-4 {
      padding-top: 1rem;
      padding-bottom: 1rem;
    }
  
.floating-logo {
  font-weight: 700;
  font-size: 1.5rem;
  background: linear-gradient(45deg, #facc15, #f472b6, #60a5fa, #8b5cf6);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: float-shine 4s infinite ease-in-out;
}

@keyframes float-shine {
  0% { transform: translateY(0px); text-shadow: 0 0 5px rgba(255,255,255,0.5); }
  50% { transform: translateY(-3px); text-shadow: 0 0 20px rgba(255,255,255,0.9); }
  100% { transform: translateY(0px); text-shadow: 0 0 5px rgba(255,255,255,0.5); }
}


/* Modern enhancements */
body {
  font-family: 'Inter', system-ui, sans-serif;
  background: linear-gradient(135deg, #fdfbfb 0%, #ebedee 100%);
  color: #1A1F2C;
  padding-top: 4rem;
}

header {
  background: #1f2937;
  padding: 1rem 2rem;
  border-bottom: 1px solid #334155;
  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}

.logo {
  font-size: 1.6rem;
}

nav ul {
  gap: 2rem;
}

nav ul li a {
  padding: 0.5rem 1rem;
  border-radius: 8px;
}

nav ul li a:hover {
  background-color: rgba(255, 255, 255, 0.1);
  transition: background 0.3s ease;
}

section {
  background: white;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  margin-bottom: 2rem;
  padding: 2rem;
}

h1, h2, h3 {
  font-weight: 700;
  color: #1e40af;
}

.accordion-header {
  font-size: 1.1rem;
  font-weight: 600;
  color: #1d4ed8;
}

.feature-card {
  background: linear-gradient(to bottom right, #e0e7ff, #f5f3ff);
  border: 1px solid #c7d2fe;
}

.card {
  background: #f9fafb;
  border: 1px solid #e5e7eb;
  padding: 1.5rem;
  border-radius: 10px;
}

footer {
  background: #f3f4f6;
  color: #1f2937;
}


/* Responsive Enhancements */
@media (max-width: 768px) {
  header {
    flex-direction: column;
    align-items: flex-start;
  }

  nav ul {
    flex-direction: column;
    gap: 1rem;
    margin-top: 1rem;
  }

  section {
    padding: 1.25rem;
  }

  h1 {
    font-size: 2rem;
  }

  .accordion-header {
    font-size: 1rem;
  }

  .feature-grid {
    grid-template-columns: 1fr;
  }

  .form-grid {
    grid-template-columns: 1fr;
  }

  .gantt-box {
    min-width: 40px;
    font-size: 0.75rem;
  }

  table, th, td {
    font-size: 0.85rem;
  }

  .tab {
    padding: 0.5rem 0.75rem;
    font-size: 0.9rem;
  }

  .steps {
    flex-direction: column;
    align-items: center;
  }

  .step {
    margin-bottom: 0.5rem;
  }
}
  </style>
 </head>
 <body>
  <div class="container">
   <h1>
    CPU Scheduling Simulator
   </h1>
   <div class="steps-container">
    <div class="step active" data-step="1">
     1. Select Algorithm
    </div>
    <div class="step" data-step="2">
     2. Add Processes
    </div>
    <div class="step" data-step="3">
     3. View Results
    </div>
   </div>
   <div class="step-content active" id="step1">
    <div class="card">
     <h2>
      Select Scheduling Algorithm
     </h2>
     <div class="form-group">
      <label for="algorithm">
       Choose Algorithm:
      </label>
      <select id="algorithm">
       <option value="">
        -- Select Algorithm --
       </option>
       <option value="FCFS">
        First Come First Served (FCFS)
       </option>
       <option value="SJF">
        Shortest Job First (Non-Preemptive)
       </option>
       <option value="SRTF">
        Shortest Remaining Time First (Preemptive)
       </option>
       <option value="PRIORITY">
        Priority Scheduling (Non-Preemptive)
       </option>
       <option value="RR">
        Round Robin
       </option>
      </select>
     </div>
     <div class="form-group" id="time-quantum-container" style="display:none;">
      <label for="time-quantum">
       Time Quantum:
      </label>
      <input id="time-quantum" min="1" type="number" value="2"/>
     </div>
     <button id="select-algorithm-btn">
      Continue to Add Processes
     </button>
    </div>
   </div>
   <div class="step-content" id="step2">
    <div class="card">
     <h2>
      Add Processes for
      <span id="selected-algorithm">
       Algorithm
      </span>
     </h2>
     <div class="form-grid">
      <div class="form-group">
       <label for="pid">
        Process ID:
       </label>
       <input id="pid" placeholder="e.g. P1" required="" type="text"/>
      </div>
      <div class="form-group">
       <label for="burst-time">
        Burst Time:
       </label>
       <input id="burst-time" min="1" placeholder="e.g. 5" required="" type="number"/>
      </div>
      <div class="form-group">
       <label for="arrival-time">
        Arrival Time:
       </label>
       <input id="arrival-time" min="0" placeholder="e.g. 0" required="" type="number"/>
      </div>
      <div class="form-group" id="priority-container" style="display:none;">
       <label for="priority">
        Priority (Lower is Higher):
       </label>
       <input id="priority" min="1" placeholder="e.g. 2" type="number"/>
      </div>
     </div>
     <button id="add-process-btn">
      Add Process
     </button>
     <button id="go-back-btn" style="background-color: #6c757d; margin-left: 10px;">
      Back to Algorithm Selection
     </button>
    </div>
    <div class="card process-list" id="process-list-container" style="display:none;">
     <h2>
      Process List
     </h2>
     <table id="process-table">
      <thead>
       <tr>
        <th>
         Process ID
        </th>
        <th>
         Arrival Time
        </th>
        <th>
         Burst Time
        </th>
        <th id="priority-header" style="display:none;">
         Priority
        </th>
        <th>
         Action
        </th>
       </tr>
      </thead>
      <tbody id="process-table-body">
       <!-- Process entries will be populated here -->
      </tbody>
     </table>
     <button id="run-algorithm-btn" style="margin-top: 16px;">
      Run Algorithm
     </button>
    </div>
   </div>
   <div class="step-content" id="step3">
    <div class="card" id="results-container">
     <h2>
      Results for
      <span id="result-algorithm">
       Algorithm
      </span>
     </h2>
     <div class="tabs">
      <div class="tab active" data-tab="gantt">
       Gantt Chart
      </div>
      <div class="tab" data-tab="table">
       Process Details
      </div>
     </div>
     <div class="tab-content" id="gantt-tab">
      <div class="gantt-container">
       <div class="gantt" id="gantt-chart">
        <!-- Gantt chart will be populated here -->
       </div>
      </div>
     </div>
     <div class="tab-content" id="table-tab" style="display:none;">
      <table id="results-table">
       <thead>
        <tr>
         <th>
          Process ID
         </th>
         <th>
          Arrival Time
         </th>
         <th>
          Burst Time
         </th>
         <th id="result-priority-header" style="display:none;">
          Priority
         </th>
         <th>
          Start Time
         </th>
         <th>
          Completion Time
         </th>
         <th>
          Turnaround Time
         </th>
         <th>
          Waiting Time
         </th>
        </tr>
       </thead>
       <tbody id="results-body">
        <!-- Results will be populated here -->
       </tbody>
      </table>
     </div>
     <div class="metrics">
      <div class="metric-group">
       <div>
        Average Turnaround Time
       </div>
       <div class="metric-value" id="avg-turnaround">
        0.00
       </div>
      </div>
      <div class="metric-group">
       <div>
        Average Waiting Time
       </div>
       <div class="metric-value" id="avg-waiting">
        0.00
       </div>
      </div>
     </div>
     <button id="start-over-btn" style="margin-top: 16px;">
      Start Over
     </button>
    </div>
   </div>
  </div>
  <script>
   // Global variables
    let currentStep = 1;
    let selectedAlgorithm = '';
    let processes = [];
    const colors = [
      '#6E59A5', '#9b87f5', '#7E69AB', '#D946EF', '#8B5CF6', 
      '#F97316', '#0EA5E9', '#1EAEDB', '#33C3F0', '#0FA0CE'
    ];
    
    // DOM Elements
    const algorithmSelect = document.getElementById('algorithm');
    const timeQuantumContainer = document.getElementById('time-quantum-container');
    const priorityContainer = document.getElementById('priority-container');
    const priorityHeader = document.getElementById('priority-header');
    const resultPriorityHeader = document.getElementById('result-priority-header');
    const selectedAlgorithmSpan = document.getElementById('selected-algorithm');
    const resultAlgorithmSpan = document.getElementById('result-algorithm');
    const processListContainer = document.getElementById('process-list-container');
    const processTableBody = document.getElementById('process-table-body');
    const ganttChart = document.getElementById('gantt-chart');
    const resultsBody = document.getElementById('results-body');
    const avgTurnaround = document.getElementById('avg-turnaround');
    const avgWaiting = document.getElementById('avg-waiting');

    // Event Listeners
    document.getElementById('select-algorithm-btn').addEventListener('click', selectAlgorithm);
    document.getElementById('add-process-btn').addEventListener('click', addProcess);
    document.getElementById('go-back-btn').addEventListener('click', goBackToAlgorithm);
    document.getElementById('run-algorithm-btn').addEventListener('click', runScheduling);
    document.getElementById('start-over-btn').addEventListener('click', startOver);
    
    algorithmSelect.addEventListener('change', function() {
      timeQuantumContainer.style.display = this.value === 'RR' ? 'block' : 'none';
    });

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const tabName = this.getAttribute('data-tab');
        
        // Update active tab
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        this.classList.add('active');
        
        // Show correct content
        document.querySelectorAll('.tab-content').forEach(content => {
          content.style.display = 'none';
        });
        document.getElementById(`${tabName}-tab`).style.display = 'block';
      });
    });

    function selectAlgorithm() {
      selectedAlgorithm = algorithmSelect.value;
      
      if (!selectedAlgorithm) {
        alert('Please select an algorithm first.');
        return;
      }
      
      // Update UI for algorithm selection
      selectedAlgorithmSpan.textContent = algorithmSelect.options[algorithmSelect.selectedIndex].text;
      resultAlgorithmSpan.textContent = algorithmSelect.options[algorithmSelect.selectedIndex].text;
      
      // Show priority field if Priority algorithm is selected
      priorityContainer.style.display = selectedAlgorithm === 'PRIORITY' ? 'block' : 'none';
      priorityHeader.style.display = selectedAlgorithm === 'PRIORITY' ? 'table-cell' : 'none';
      resultPriorityHeader.style.display = selectedAlgorithm === 'PRIORITY' ? 'table-cell' : 'none';
      
      // Reset processes for new algorithm
      processes = [];
      updateProcessTable();
      
      // Move to step 2
      goToStep(2);
    }

    function goToStep(step) {
      // Hide all steps
      document.querySelectorAll('.step-content').forEach(el => {
        el.classList.remove('active');
      });
      
      // Mark all step indicators
      document.querySelectorAll('.step').forEach(el => {
        el.classList.remove('active');
      });
      
      // Show selected step
      document.getElementById(`step${step}`).classList.add('active');
      document.querySelector(`.step[data-step="${step}"]`).classList.add('active');
      
      currentStep = step;
    }

    function goBackToAlgorithm() {
      goToStep(1);
    }

    function addProcess() {
      const pid = document.getElementById('pid').value.trim();
      const burstTime = parseInt(document.getElementById('burst-time').value);
      const arrivalTime = parseInt(document.getElementById('arrival-time').value);
      const priority = parseInt(document.getElementById('priority').value) || 1;

      // Validate inputs
      if (!pid || isNaN(burstTime) || burstTime <= 0 || isNaN(arrivalTime) || arrivalTime < 0) {
        alert('Please enter valid values for all fields.');
        return;
      }

      // Check for duplicate process ID
      if (processes.some(p => p.pid === pid)) {
        alert('A process with this ID already exists. Please use a unique ID.');
        return;
      }

      // Add new process
      processes.push({ pid, bt: burstTime, at: arrivalTime, prio: priority });
      
      // Reset input fields
      document.getElementById('pid').value = '';
      document.getElementById('burst-time').value = '';
      document.getElementById('arrival-time').value = '';
      document.getElementById('priority').value = '';
      
      // Update process table
      updateProcessTable();
    }

    function updateProcessTable() {
      // Clear table body
      processTableBody.innerHTML = '';
      
      // Show/hide process list based on whether there are processes
      processListContainer.style.display = processes.length > 0 ? 'block' : 'none';
      
      // Add each process to the table
      processes.forEach((process, index) => {
        const row = document.createElement('tr');
        
        let cells = `
          <td>${process.pid}</td>
          <td>${process.at}</td>
          <td>${process.bt}</td>
        `;
        
        if (selectedAlgorithm === 'PRIORITY') {
          cells += `<td>${process.prio}</td>`;
        }
        
        cells += `<td><button class="action-btn" onclick="deleteProcess(${index})">Delete</button></td>`;
        
        row.innerHTML = cells;
        processTableBody.appendChild(row);
      });
    }

    // This function needs to be global for the onclick handler
    window.deleteProcess = function(index) {
      processes.splice(index, 1);
      updateProcessTable();
    };

    function startOver() {
      // Reset everything
      processes = [];
      selectedAlgorithm = '';
      algorithmSelect.value = '';
      document.getElementById('time-quantum').value = '2';
      timeQuantumContainer.style.display = 'none';
      updateProcessTable();
      
      // Go back to step 1
      goToStep(1);
    }

    function runScheduling() {
      if (processes.length === 0) {
        alert('Please add at least one process first.');
        return;
      }
      
      let results;
      
      switch (selectedAlgorithm) {
        case 'FCFS':
          results = calculateFCFS();
          break;
        case 'SJF':
          results = calculateSJF();
          break;
        case 'SRTF':
          results = calculateSRTF();
          break;
        case 'PRIORITY':
          results = calculatePriority();
          break;
        case 'RR':
          const timeQuantum = parseInt(document.getElementById('time-quantum').value);
          if (isNaN(timeQuantum) || timeQuantum <= 0) {
            alert('Please enter a valid time quantum.');
            return;
          }
          results = calculateRoundRobin(timeQuantum);
          break;
      }
      
      displayResults(results);
      goToStep(3);
    }

    function calculateFCFS() {
      // Create deep copy of processes and sort by arrival time
      const sortedProcesses = JSON.parse(JSON.stringify(processes))
        .sort((a, b) => a.at - b.at);
      
      let currentTime = 0;
      const ganttData = [];
      
      // Calculate times for each process
      sortedProcesses.forEach(process => {
        // If process hasn't arrived yet, advance time
        if (currentTime < process.at) {
          currentTime = process.at;
        }
        
        // Set start time
        process.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: process.pid,
          start: currentTime,
          end: currentTime + process.bt,
          color: getProcessColor(process.pid)
        });
        
        // Update current time
        currentTime += process.bt;
        
        // Set completion time
        process.end = currentTime;
        
        // Calculate turnaround and waiting times
        process.tat = process.end - process.at;
        process.wt = process.tat - process.bt;
      });
      
      // Calculate averages
      const avgTAT = sortedProcesses.reduce((sum, p) => sum + p.tat, 0) / sortedProcesses.length;
      const avgWT = sortedProcesses.reduce((sum, p) => sum + p.wt, 0) / sortedProcesses.length;
      
      return {
        processes: sortedProcesses,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateSJF() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && !p.completed);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => !p.completed)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find shortest job among eligible processes
        let shortestJob = eligible.reduce(
          (min, p) => p.bt < min.bt ? p : min, 
          eligible[0]
        );
        
        // Mark start time
        shortestJob.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: shortestJob.pid,
          start: currentTime,
          end: currentTime + shortestJob.bt,
          color: getProcessColor(shortestJob.pid)
        });
        
        // Update current time
        currentTime += shortestJob.bt;
        
        // Mark completion
        shortestJob.completed = true;
        shortestJob.end = currentTime;
        shortestJob.tat = shortestJob.end - shortestJob.at;
        shortestJob.wt = shortestJob.tat - shortestJob.bt;
        completed++;
      }
      
      // Remove temporary 'completed' property
      processData.forEach(p => delete p.completed);
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateSRTF() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      // Initialize remaining time for each process
      processData.forEach(p => {
        p.remaining = p.bt;
        p.executed = false;
      });
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      let previousProcess = null;
      let startTime = 0;
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && p.remaining > 0);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => p.remaining > 0)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find process with shortest remaining time
        let shortestJob = eligible.reduce(
          (min, p) => p.remaining < min.remaining ? p : min, 
          eligible[0]
        );
        
        // If this is the first time this process executes, mark its start time
        if (!shortestJob.executed) {
          shortestJob.start = currentTime;
          shortestJob.executed = true;
        }
        
        // If process changes, add previous process execution to Gantt chart
        if (previousProcess !== null && previousProcess !== shortestJob.pid) {
          ganttData.push({
            pid: previousProcess,
            start: startTime,
            end: currentTime,
            color: getProcessColor(previousProcess)
          });
          
          startTime = currentTime;
        } else if (previousProcess === null) {
          startTime = currentTime;
        }
        
        // Update previous process
        previousProcess = shortestJob.pid;
        
        // Execute for 1 time unit
        shortestJob.remaining--;
        currentTime++;
        
        // Check if process completed
        if (shortestJob.remaining === 0) {
          // Mark completion
          shortestJob.end = currentTime;
          shortestJob.tat = shortestJob.end - shortestJob.at;
          shortestJob.wt = shortestJob.tat - shortestJob.bt;
          completed++;
          
          // Add to Gantt chart
          ganttData.push({
            pid: shortestJob.pid,
            start: startTime,
            end: currentTime,
            color: getProcessColor(shortestJob.pid)
          });
          
          previousProcess = null;
          startTime = currentTime;
        }
      }
      
      // Remove temporary properties
      processData.forEach(p => {
        delete p.remaining;
        delete p.executed;
      });
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculatePriority() {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      
      // Continue until all processes are completed
      while (completed < processData.length) {
        // Find eligible processes (those that have arrived)
        let eligible = processData.filter(p => p.at <= currentTime && !p.completed);
        
        if (eligible.length === 0) {
          // If no processes are eligible, advance time to next arrival
          const nextArrival = Math.min(...processData
            .filter(p => !p.completed)
            .map(p => p.at));
          currentTime = nextArrival;
          continue;
        }
        
        // Find process with highest priority (lower number = higher priority)
        let highestPriority = eligible.reduce(
          (min, p) => p.prio < min.prio ? p : min, 
          eligible[0]
        );
        
        // Mark start time
        highestPriority.start = currentTime;
        
        // Add to Gantt chart
        ganttData.push({
          pid: highestPriority.pid,
          start: currentTime,
          end: currentTime + highestPriority.bt,
          color: getProcessColor(highestPriority.pid)
        });
        
        // Update current time
        currentTime += highestPriority.bt;
        
        // Mark completion
        highestPriority.completed = true;
        highestPriority.end = currentTime;
        highestPriority.tat = highestPriority.end - highestPriority.at;
        highestPriority.wt = highestPriority.tat - highestPriority.bt;
        completed++;
      }
      
      // Remove temporary 'completed' property
      processData.forEach(p => delete p.completed);
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function calculateRoundRobin(timeQuantum) {
      // Create deep copy of processes
      const processData = JSON.parse(JSON.stringify(processes));
      
      // Initialize remaining time for each process
      processData.forEach(p => {
        p.remaining = p.bt;
        p.executed = false;
      });
      
      let currentTime = 0;
      let completed = 0;
      const ganttData = [];
      const readyQueue = [];
      
      // Continue until all processes are completed
      while (completed < processData.length || readyQueue.length > 0) {
        // Add newly arrived processes to ready queue
        processData.forEach(p => {
          if (p.at <= currentTime && !p.inQueue && p.remaining > 0) {
            readyQueue.push(p);
            p.inQueue = true;
          }
        });
        
        if (readyQueue.length === 0) {
          // If no processes in ready queue, advance time to next arrival
          const remainingProcesses = processData.filter(p => p.remaining > 0 && !p.inQueue);
          if (remainingProcesses.length > 0) {
            const nextArrival = Math.min(...remainingProcesses.map(p => p.at));
            currentTime = nextArrival;
            continue;
          } else {
            // All processes have completed
            break;
          }
        }
        
        // Get next process from ready queue
        const currentProcess = readyQueue.shift();
        
        // If this is the first time this process executes, mark its start time
        if (!currentProcess.executed) {
          currentProcess.start = currentTime;
          currentProcess.executed = true;
        }
        
        // Calculate execution time (either time quantum or remaining time, whichever is smaller)
        const executeTime = Math.min(timeQuantum, currentProcess.remaining);
        
        // Add to Gantt chart
        ganttData.push({
          pid: currentProcess.pid,
          start: currentTime,
          end: currentTime + executeTime,
          color: getProcessColor(currentProcess.pid)
        });
        
        // Update current time and remaining time
        currentTime += executeTime;
        currentProcess.remaining -= executeTime;
        
        // Add newly arrived processes to ready queue
        processData.forEach(p => {
          if (p.at <= currentTime && !p.inQueue && p.remaining > 0) {
            readyQueue.push(p);
            p.inQueue = true;
          }
        });
        
        // Check if process completed
        if (currentProcess.remaining === 0) {
          // Mark completion
          currentProcess.end = currentTime;
          currentProcess.tat = currentProcess.end - currentProcess.at;
          currentProcess.wt = currentProcess.tat - currentProcess.bt;
          completed++;
        } else {
          // Put back in ready queue
          readyQueue.push(currentProcess);
        }
      }
      
      // Remove temporary properties
      processData.forEach(p => {
        delete p.remaining;
        delete p.executed;
        delete p.inQueue;
      });
      
      // Calculate averages
      const avgTAT = processData.reduce((sum, p) => sum + p.tat, 0) / processData.length;
      const avgWT = processData.reduce((sum, p) => sum + p.wt, 0) / processData.length;
      
      return {
        processes: processData,
        ganttData,
        avgTAT,
        avgWT
      };
    }

    function displayResults(results) {
      // Clear previous results
      ganttChart.innerHTML = '';
      resultsBody.innerHTML = '';
      
      // Display Gantt chart
      results.ganttData.forEach(item => {
        const width = (item.end - item.start) * 40; // 40px per time unit
        
        const ganttBox = document.createElement('div');
        ganttBox.className = 'gantt-box';
        ganttBox.style.backgroundColor = item.color;
        ganttBox.style.width = `${width}px`;
        ganttBox.innerHTML = item.pid;
        
        // Add start time marker
        const startMarker = document.createElement('div');
        startMarker.className = 'time-marker';
        startMarker.textContent = item.start;
        ganttBox.appendChild(startMarker);
        
        // Add end time marker (only for the last item)
        if (item === results.ganttData[results.ganttData.length - 1]) {
          const endMarker = document.createElement('div');
          endMarker.className = 'time-marker end';
          endMarker.textContent = item.end;
          ganttBox.appendChild(endMarker);
        }
        
        ganttChart.appendChild(ganttBox);
      });
      
      // Display process details
      results.processes.forEach(process => {
        const row = document.createElement('tr');
        
        let cells = `
          <td>${process.pid}</td>
          <td>${process.at}</td>
          <td>${process.bt}</td>
        `;
        
        if (selectedAlgorithm === 'PRIORITY') {
          cells += `<td>${process.prio}</td>`;
        }
        
        cells += `
          <td>${process.start}</td>
          <td>${process.end}</td>
          <td>${process.tat}</td>
          <td>${process.wt}</td>
        `;
        
        row.innerHTML = cells;
        resultsBody.appendChild(row);
      });
      
      // Display average metrics
      avgTurnaround.textContent = results.avgTAT.toFixed(2);
      avgWaiting.textContent = results.avgWT.toFixed(2);
    }

    function getProcessColor(pid) {
      // Generate a consistent color based on process ID
      const index = Array.from(pid).reduce((sum, char) => sum + char.charCodeAt(0), 0) % colors.length;
      return colors[index];
    }
  </script>
 </body>
</html>
